## 分组密码

### AES

#### AES 参数

* 块大小128

* 密钥大小为128、192和256位

* 每个密钥大小为10、12或14轮加密

以 AES-128 为例。

AES是一个替换置换网络（不是Feistel网络）。


首先将消息安排在元素为8比特的4 × 4矩阵中，向下填充，然后向右填充。

#### AES 操作

* 字节代换（S盒）：对每个字节进行独立操作。这就给出了 AES 的非线性和混淆。


* 字节排列：行移位
* 列操作：列混淆
  * 行移位和列混淆提供了 AES 中的扩散。

* 轮密钥加

这 10 轮加密过程之前会有一次密钥加法（因此，总共有 11 次密钥加法）。最后一轮稍有不同：没有列混淆操作。

<img src="../img/AES.png" alt="AES" style="zoom:50%;" />

##### AES 的字节操作

AES 是一种面向字节的加密算法。被各轮操作处理的 128 位“状态”（state）被视为 16 个字节，并排列成一个矩阵的形式：

<img src="../img/AES_matrix.png" alt="AES_matrix" style="zoom:80%;" />

* $\oplus$ ：按位异或

* $\otimes$ ：$F_{2^8}$上的乘法 $F_2[x]$

​		如：$0x53 \otimes 0xCA / (x^8 + x^4 + x^3 + x + 1)$

​			$=(x^6+x^4+x+1)(x^7+x^6+x^3+x)/(x^8 + x^4 + x^3 + x + 1)$
​				$=0x01$

##### 字节代换

<img src="../img/AES-SubBytes.svg.png" alt="AES-SubBytes.svg" style="zoom: 25%;" />

矩阵中的各字节透过一个8位的[S-box](https://en.wikipedia.org/wiki/Rijndael_S-box#Forward_S-box)进行转换。这个步骤提供了非线性的变换能力。

##### 行移位

<img src="../img/AES-ShiftRows.svg.png" alt="AES-ShiftRows.svg" style="zoom: 33%;" />

##### 列混淆

<img src="../img/AES-MixColumns.svg.png" alt="AES-MixColumns.svg" style="zoom: 25%;" />

将每一列分别混合，通过与矩阵相乘来实现：

<img src="../img/AES_matrix_times.png" alt="AES_matrix_times" style="zoom: 67%;" />

每一列的四个字节透过[线性变换](https://zh.wikipedia.org/wiki/线性变换)互相结合。每一列的四个元素分别当作 $1,x,x_2,x_3$ 的系数，合并即为 $GF(2^8)$ 中的一个多项式，接着将此多项式和一个固定的多项式 $c(x)=3x^3+x^2+x+2$ 在模 $x^4+1$ 下相乘。

##### 轮密钥加

<img src="../img/AES-AddRoundKey.svg.png" alt="AES-AddRoundKey.svg" style="zoom: 33%;" />

#### 密钥调度

派生轮密钥 $K_i$ 的方法如下：将 $K$ 分成四个字 $W_0,W_1,W_2$ 和 $W_3$ 各32位。

```c++
for i:=1 to 10 do
    T:=W[4i-1]<<<8
    T:=SubBytes(T)
    T:=T⊕RC[i]
    W[4i]:= W[4i−4]⊕T
    W[4i+1]:= W[4i−3]⊕W[4i]
    W[4i+2]:= W[4i−2]⊕W[4i+1]
    W[4i+3]:= W[4i−1]⊕W[4i+2]
end
```

* 轮密钥$K_i = W_{4i}, W_{4i+1}, W_{4i+2}, W_{4i+3}$

* 常数 $RC_i=0x\space rc_i000000$

​	$rc_i=x^{i-1}\bmod x^8 + x^4 + x^3 + x + 1$

### SM4

#### 核心定位与特性

SM4全称为“SM4分组密码算法”，由国家密码管理局发布，标准号为GB/T 32907-2016，其核心定位是满足国内商用领域的数据加密需求，替代部分国外算法实现自主可控。

其核心特性主要包括三点：

1. **分组与密钥长度固定**：分组长度和密钥长度均为128位，这一设计平衡了安全性和计算效率，能有效抵御常见的密码分析攻击。
2. **对称密码体制**：加密和解密使用相同的密钥，操作流程对称，便于硬件和软件快速实现，适合对处理速度有要求的场景。
3. **国产化自主可控**：算法设计完全由国内团队完成，无外部后门风险，符合国家信息安全战略，是政务、金融等关键领域的首选加密算法之一。

#### 算法原理

SM4算法是一种典型的迭代型分组密码，基于“代换-置换网络（Substitution-Permutation Network，SPN）”结构设计，其核心设计思路是通过多轮次的非线性代换（混淆）和线性置换（扩散）操作，将明文数据转化为完全不可识别的密文，同时保证加密与解密过程的对称性和高效性。整体加密流程可细分为**初始变换**、**32轮轮函数迭代**、**反初始变换**三个核心阶段，而支撑整个流程的关键还有**密钥扩展算法**，用于生成每轮迭代所需的轮密钥。

1. **轮函数迭代（核心执行环节）**：轮函数是SM4加密的核心模块，32轮迭代过程采用完全相同的结构，每轮操作都实现一次“混淆-扩散”循环。具体流程如下：首先，将128位明文分组划分为4个32位的字，记为X₀、X₁、X₂、X₃（后续每轮迭代的输入均为4个32位字）；然后，取后3个输入字Xᵢ₊₁、Xᵢ₊₂、Xᵢ₊₃与本轮轮密钥rkᵢ进行“轮函数F”运算，得到的结果再与第一个输入字Xᵢ进行异或（XOR）操作，生成新的字Xᵢ₊₄，同时将Xᵢ₊₁、Xᵢ₊₂、Xᵢ₊₃、Xᵢ₊₄作为下一轮迭代的输入，依次循环32轮。其中“轮函数F”包含四个关键子操作，按顺序执行： 

2. **字节代换（S盒变换）**：这是实现非线性混淆的核心步骤。将32位输入字拆分为4个8位字节，每个字节通过SM4专用S盒进行查表替换。S盒是基于GF(2⁸)有限域上的逆运算和仿射变换设计的，具有良好的非线性特性和抗差分攻击能力，能有效打破输入与输出之间的线性关联； 

3. **行移位（字节移位）**：对S盒输出的4个字节进行循环移位操作，第一个字节不移位，第二个字节左移1个字节，第三个字节左移2个字节，第四个字节左移3个字节。该操作通过位置置换实现字节级别的扩散，使单个字节的变化影响到多个位置； 3. **列混合（线性变换）**：对行移位后的4个字节进行线性变换，通过固定的线性矩阵与字节向量相乘（基于GF(2)域运算），将单个字节的信息扩散到整个32位字中，进一步增强数据的扩散效果； 

4. **轮密钥加（异或操作）**：将列混合后的32位结果与本轮轮密钥rkᵢ进行异或运算，实现密钥信息与明文信息的深度融合。32轮迭代完成后，得到的4个32位字X₃₂、X₃₃、X₃₄、X₃₅需经过“反初始变换”（即将4个字按X₃₅、X₃₄、X₃₃、X₃₂的顺序重组为128位数据），最终得到128位密文。

   

- **密钥扩展算法（轮密钥生成）**：SM4的加密和解密均依赖128位主密钥，但每轮轮函数需要独立的32位轮密钥，因此需通过密钥扩展算法将128位主密钥扩展为32个32位轮密钥（rk₀至rk₃₁）。具体步骤为：首先将128位主密钥拆分为4个32位字MK₀、MK₁、MK₂、MK₃，与4个固定的32位系统参数FK₀、FK₁、FK₂、FK₃分别异或，得到密钥扩展的初始输入字K₀、K₁、K₂、K₃；然后采用与轮函数类似的迭代方式生成后续密钥字，对于第i轮（i从0到31），取前4个密钥字中的后3个（Kᵢ₊₁、Kᵢ₊₂、Kᵢ₊₃）与一个固定的32位常量CKᵢ进行“密钥扩展函数G”运算，结果再与第一个密钥字Kᵢ异或，得到新的密钥字Kᵢ₊₄，其中Kᵢ₊₄即为第i轮的轮密钥rkᵢ。“密钥扩展函数G”同样包含S盒字节代换和线性变换操作，确保生成的轮密钥具有良好的随机性和独立性，避免因主密钥泄露或轮密钥关联性导致的安全风险。

- **解密原理（对称结构设计）**：SM4的解密过程与加密过程在结构上完全对称，核心优势是无需重新生成解密密钥，仅需将加密时使用的32个轮密钥按逆序（即rk₃₁至rk₀）使用即可。这是因为轮函数具有“可逆性”——字节代换的逆操作可通过S盒的逆表实现，行移位的逆操作是反向循环移位，列混合的逆操作可通过逆线性矩阵实现，而异或操作本身是自逆的。因此，解密时只需将密文作为输入，按加密的反向流程执行32轮迭代（使用逆序轮密钥），再经过初始变换（与加密的反初始变换对称），即可还原出原始明文，这种对称设计极大简化了算法的硬件和软件实现复杂度。

#### 与国际算法对比

目前国际上主流的分组密码算法是AES，SM4与AES在设计和应用上既有共性，也存在显著差异，具体对比如下：

| 对比维度      | SM4算法                                    | AES算法                                    |
| ------------- | ------------------------------------------ | ------------------------------------------ |
| 设计主体      | 中国国家密码管理局                         | 美国国家标准与技术研究院（NIST）           |
| 分组/密钥长度 | 均固定为128位                              | 分组128位，密钥支持128/192/256位           |
| 算法结构      | 32轮SPN结构                                | 10/12/14轮SPN结构（依密钥长度）            |
| 安全性        | 抵御差分、线性等攻击，无公开安全漏洞       | 国际公认安全，应用广泛，经过长期验证       |
| 适用场景      | 国内政务、金融、物联网等需国产化合规的领域 | 全球通用，适用于互联网、跨境业务等国际场景 |

#### 

### 分组密码的工作模式

一个好的分组密码模式应该具有以下属性：

1. 安全性（保密性）：相同的明文不应产生相同的密文；明文中的相同块不应该产生相同的密文块。
2. 安全性（完整性）：应该有防止删除或插入块的保护。
3. 恢复：密文传输错误应该只影响包含错误的块。
4. 效率：它应该是有效率的（例如，可并行）。

#### PKCS#7填充

PKCS#7 标准规定，填充字节的值等于填充的长度（如填充 6 字节则每个字节为`0x06`），解密时通过最后一个字节的值即可知道需要去除多少填充。

#### ECB

* 加密：

  <img src="../img/Ecb_encryption.png" alt="Ecb_encryption" style="zoom: 80%;" />

* 解密：

  <img src="../img/Ecb_decryption.png" alt="Ecb_decryption" style="zoom: 80%;" />

* ECB 不符合属性1和2。它满足3和4，但不如1和2重要。

#### CBC

* 加密：

  <img src="../img/Cbc_encryption.png" alt="Cbc_encryption" style="zoom: 80%;" />

​	$C_i=E_k(P_i \oplus C_{i-1} )$

​	$C_0=IV$

* 每次加密都应该随机选择IV。

  * 必须将IV与密文一起存储，否则无法解密。因此，IV是*随机的*，但不是*秘密的*。

  * 由于密文包含IV，因此它比明文长一个块。所以在长度上有小扩展。

* CBC 满足属性1，但不满足属性2，3和4。

* 解密：

  <img src="../img/Cbc_decryption.png" alt="Cbc_decryption" style="zoom:80%;" />

​	$P_i=D_k(C_i) \oplus C_{i-1}$

​	$C_0=IV$

* 在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。
  * 因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。

#### CTR

* 加密：

  <img src="../img/Ctr_encryption.png" alt="Ctr_encryption" style="zoom:80%;" />

* CTR 满足属性1，3和4，但不满足属性2。

* 解密：

  <img src="../img/Ctr_decryption.png" alt="Ctr_decryption" style="zoom:80%;" />

### 加密系统的安全性

#### 加密系统安全性的定义

1. 给定一个密文，攻击者（在没有密钥的情况下）绝对无法获得明文。
   * 不安全，如 3DES 会泄露明文块是否相同。
2. 给定一个密文，攻击者可以仅通过 $N$ 单位的工作量获得明文。
   * 不安全，攻击者可能足够幸运猜出密钥。

3. 给定一个密文，攻击者要么通过消耗 $N$ 单位的工作量获得明文，要么以最多 $\frac{1}{M}$ 的概率猜测明文或密钥。
   * 不安全，攻击者可以获得关于明文内容的统计信息。

4. 给定一个密文，攻击者不能推测明文的**任何信息**，除非消耗 $N$ 单位的工作量获得明文，或者以最多 $\frac{1}{M}$ 的概率猜测明文或密钥。

#### IND-CPA

基于选择明文攻击的不可区分性

1. 挑战者：$k$ --> 攻击者
2. 攻击者：$m_0,m_1$ --> 挑战者
3. 挑战者：$b\in \{0,1\}$, $Enc_k(m_b)$ -->攻击者
4. 攻击者：$b'$ --> 挑战者

5. if $b'=b$，挑战者获胜

#### IND-CCA

基于选择密文攻击的不可区分性

1. 密钥生成：

   - 挑战者生成一个公私钥对 $(pk,sk)$。

   - 挑战者将公钥 $pk$发送给攻击者。

2. 攻击者的查询阶段：

   - 攻击者可以选择一些密文 ，并向挑战者查询它们的解密结果。

   - 挑战者用私钥 $sk$ 解密密文，计算 $m=Dec(sk,c)$，然后将明文 $m$ 返回给攻击者。

   - 这一阶段允许攻击者了解部分密文的解密结果，但不包括稍后被标记为挑战密文的密文。

3. 挑战阶段：

   - 攻击者选择两条明文 $m_0$ 和 $m_1$，并将它们发送给挑战者。这两条明文通常是相同长度的。

   - 挑战者随机选择一个位 $b \in \{0, 1\}$，并用公钥 $pk$ 对 $m_b$进行加密，得到挑战密文 $c^* = Enc(pk, m_b)$。

   - 挑战密文 $c^*$ 被发送给攻击者。

4. 攻击者的查询阶段：

   - 攻击者可以再次进行解密查询，但有一个限制：攻击者不能查询挑战密文 $c^*$ 的解密结果。

   - 对于其他密文 $c \neq c^*$，挑战者仍然会解密并返回 $m = Dec(sk, c)$。

5. 攻击者的猜测：
   - 最终，攻击者输出一个猜测值 $b^*$，试图猜测挑战密文 $c^*$ 中对应的明文是 $m_0$ 还是 $m_1$。

6. 胜利条件：
   - 如果攻击者的猜测 $b^*$ 与挑战者选择的 $b$ 相同（即 $b = b^*$∗），攻击者赢得挑战。
   - 如果在多次实验中，无论攻击者的策略如何，其成功概率都不能显著超过随机猜测（50%），则加密方案是 **IND-CCA 安全的**，。

## Hash 函数

### MD5



### SHA



### SM3

SM3是我国自主设计的密码杂凑算法（哈希算法），于2010年与SM2一同成为国家密码标准（GB/T 32905-2016），是我国商用密码体系的核心组成部分之一。其核心功能是将任意长度的输入数据（明文）映射为固定长度（256位）的输出数据（哈希值/摘要），具有抗碰撞性、抗原像性等关键安全特性，广泛配合SM2等算法使用，为数字签名、数据完整性校验、密钥派生等场景提供基础安全保障。

SM3是一种迭代型密码杂凑算法，基于Merkle-Damgård结构设计，通过固定的运算步骤将任意长度的输入消息压缩为256位的哈希值。与国际通用的SHA-256算法相比，SM3在运算逻辑、轮函数设计上存在差异，但安全强度等效，且更适配我国密码体系的协同需求，常与SM2（签名/加密）、SM4（对称加密）协同工作，形成完整的密码保障链条。

#### 算法核心原理与运算流程

SM3的运算流程遵循迭代型杂凑算法的通用框架，分为“消息预处理”和“迭代压缩”两大阶段，最终通过“输出变换”得到256位哈希值。每个阶段的具体步骤如下：

##### 第一阶段：消息预处理

预处理的目的是将任意长度的原始消息转换为固定长度的消息块序列，为后续迭代压缩做准备，包括“消息填充”和“消息分组”两个步骤。

###### 消息填充

填充的核心要求是使消息总长度满足“对512取余等于448”，具体步骤：

1. 在原始消息M后添加一个“1”比特，即二进制的“1”；
2. 在“1”后添加若干个“0”比特，添加的数量k满足“(原始消息长度 + 1 + k) mod 512 = 448”，k的取值范围为0≤k≤511；
3. 在填充的“0”后添加一个64位的整数，该整数表示原始消息M的长度（单位：比特），若原始消息长度超过2^64比特，仅取低64位。

示例：若原始消息长度为1比特（值为“0”），则填充过程为：添加“1”→添加446个“0”→添加64位长度值“0x0000000000000001”，最终填充后消息长度为512比特（448+64）。

###### 消息分组

将填充后的消息按512比特（64字节）为一个分组，划分为若干个消息块M_0, M_1, ..., M_{n-1}，若填充后消息长度为L，则n = L / 512，且n≥1。每个消息块将作为后续迭代压缩的输入单元。

##### 第二阶段：迭代压缩

迭代压缩是SM3的核心环节，以512位消息块为单位，通过“压缩函数f”对初始哈希值进行迭代更新，最终得到中间哈希值。该阶段涉及“初始值设置”“消息扩展”“压缩函数运算”三个关键步骤。

###### 初始哈希值设置

SM3的初始哈希值（IV）为8个32位寄存器，其初始值由标准规定，采用十六进制表示为：

IV = (A, B, C, D, E, F, G, H) = (0x7380166F, 0x4914B2B9, 0x172442D7, 0xDA8A0600, 0xA96F30BC, 0x163138AA, 0xE38DEE4D, 0xB0FB0E4E)

这8个初始值是经过安全设计的固定常量，确保迭代压缩的初始状态具有随机性和安全性。

###### 消息扩展

为增强算法的抗攻击能力，SM3将每个512位消息块M_i扩展为132个32位字W_0, W_1, ..., W_131，分为“前68个字扩展”和“后64个字扩展”两部分：

1. **前68个字生成（W_0至W_67）**：将512位消息块M_i按32位为单位划分为16个字W_0至W_15；对于W_j（16≤j≤67），通过以下公式计算：W_j = P1(W_{j-16} ⊕ W_{j-9} ⊕ (W_{j-3} << 15)) ⊕ (W_{j-13} << 7) ⊕ W_{j-6}。其中P1为置换函数，定义为P1(X) = X ⊕ (X << 15) ⊕ (X << 23)，“⊕”为异或运算，“<<”为左移运算。
2. **后64个字生成（W_68至W_131）**：对于W_j（68≤j≤131），通过公式W_j = W_{j-64} ⊕ W_{j-68}计算，用于后续压缩函数的轮运算。

###### 压缩函数运算

压缩函数f以初始哈希值（或上一轮迭代的输出哈希值）和扩展后的132个字为输入，经过64轮迭代运算更新8个32位寄存器的值，得到本轮迭代的输出哈希值。具体步骤：

1. 将上一轮输出的哈希值（初始轮为IV）赋值给8个临时寄存器：a=A, b=B, c=C, d=D, e=E, f=F, g=G, h=H；
2. 进行64轮轮运算，每一轮以W_j和W_{j+68}（j从0到63）为输入，通过轮函数更新a-h的值。轮函数的核心是“布尔函数”和“置换运算”，其中布尔函数根据轮数不同分为FF_j和GG_j：        当0≤j≤15时，FF_j(X,Y,Z) = X ⊕ Y ⊕ Z，GG_j(X,Y,Z) = X ⊕ Y ⊕ Z；
3. 当16≤j≤63时，FF_j(X,Y,Z) = (X ∧ Y) ∨ (X ∧ Z) ∨ (Y ∧ Z)，GG_j(X,Y,Z) = (X ∧ Y) ∨ (¬X ∧ Z)；
4. 64轮运算结束后，将a-h分别与初始的A-H进行异或，得到本轮迭代的输出哈希值（A', B', C', D', E', F', G', H'），该值将作为下一个消息块的输入哈希值。

##### 第三阶段：输出变换

当所有消息块均完成迭代压缩后，最后一轮的输出哈希值（8个32位寄存器值）直接拼接为256位的最终哈希值，即SM3(M) = A' || B' || C' || D' || E' || F' || G' || H'（“||”表示字节拼接）。

#### SM3与国际算法的核心差异

作为256位安全级别的杂凑算法，SM3常与国际通用的SHA-256对比，两者在安全强度上等效，但在设计细节和应用场景上存在显著差异，具体对比如下：

| 对比维度   | SM3                                                      | SHA-256                                                     |
| :--------- | :------------------------------------------------------- | :---------------------------------------------------------- |
| 标准归属   | 中国国家密码标准（GB/T 32905-2016）                      | 美国NIST标准（FIPS 180-4）                                  |
| 消息扩展   | 将512位块扩展为132个32位字，含P1置换函数，扩展逻辑更复杂 | 将512位块扩展为64个32位字，无额外置换函数，扩展逻辑相对简洁 |
| 轮函数设计 | 64轮运算，布尔函数FF_j、GG_j分两段设计，含P0/P1置换      | 64轮运算，布尔函数Ch、Maj固定，无额外置换                   |
| 初始哈希值 | 自定义8个32位常量（如0x7380166F等）                      | 基于平方根和对数的小数部分取整（如0x6A09E667等）            |
| 应用场景   | 我国金融、政务、军工等关键领域强制合规，配合SM2/SM4使用  | 国际通用场景（如TLS、区块链、软件签名等）                   |
| 实现效率   | 软件实现效率略低于SHA-256，硬件实现适配性强              | 通用CPU上软件实现效率较高，优化成熟                         |





## 公钥密码

### RSA

#### 公钥与私钥

1. 随意选择两个大素数 $p$ 和 $q$, $ p\ne q$, 计算 $N=pq$.

2. 根据欧拉函数，求得 $r=\phi(N)=\phi(p) \times \phi(q)=(p-1)(q-1)$

3. 选择$e<r$ ($gcd(e,r)=1$). 求得$d, ed=1 \bmod r$

4. 销毁$p,q$

5. $pk=(N,e)$

   $sk=(N,d)$

#### 加密

将消息 $m$ 转换为小于 $N$ 的非负整数 $n$：

$c=n^e\bmod N$

#### 解密

$n=c^d\bmod N$

###### 原理

$c^d=n^{ed}\bmod N$

已知 $ed=1 \bmod r$，即 $ed=1+h\phi(N)$，那么有

$n^{ed}=n^{1+h\phi(N)}=n\cdot (n^{\phi(N)})^h$

若 $n$ 与 $N$ 互素，则由欧拉定理得：

$n^{ed}=n\cdot (n^{\phi(N)})^h=n(1)^h=n\bmod N$

若 $n$ 与 $N$ 不互素，则不失一般性考虑 $n=pt$, 以及 $ed-1=k(q-1)$，得：

$n^{ed}=(pt)^{ed}=0=pt=n\bmod p$

$n^{ed}=n^{ed-1}n=n^{k(q-1)}n=(n^{q-1})^kn=1^kn=n\bmod q$

故 $n^{ed}=n \bmod N$ 得证

#### IND-CPA安全结构：使用RSA加密

<img src="../img/Encryption using RSA.png" alt="Encryption using RSA" style="zoom:67%;" />

$c=m \oplus H(r)\space||\space RSA.ENC_{sk}(r)$

#### 可以直接使用 RSA 实现单向安全吗

* 不。带有小消息和小 $e$ 的 RSA 函数不安全：

  * 假设 $p, q > 10^6$. 因此$N = pq > 10^{12}$
  * 假设 $e = 7$ 和消息 $m = 5$
  * 计算 $c = m^e \bmod N = 5^7 \bmod N = 78125\bmod N = 78125$

* 密文很小，所以 $mod N$ 没有效果。$c = m^e$

  * $\log_{10}c= e\log_{10}\implies m=10^{\frac{\log C}{e}}$
  * 在我们的例子中 $log 78125 = 4.892$。因此 $\frac{log c}{e} = 0:698$

  * 恢复 $m=10^{0.698} = 5$

#### 填充:PKCS ##1v1:5

* 随机填充

​	$y = 0x00||0x02||r||0x00||m$

​	$c = y^e\bmod N$

* SSL的解密后处理（1998年前）

  $y = c^d mod N$
  检查 $y$ 的前两个字节。如果 $y \ne 0x00||0x02||... $ 输出 **Bad Format** ，否则输出 $m$

###### 选择密文攻击：Bleichenbacher 攻击

* 得到一个密文 $c = y^e mod N$。
  * 计算 $c' = c\cdot s^e\bmod N = (y\cdot s)^e\bmod N$，取合适的 $s$。

* 检查服务器是否接受 $c'$。

* $N$ 是一个 $k$ 字节数

  * $2.2^{8(k−2)}\leq ys \bmod N < 3.2^{8(k−2)}$ 和

  * $2.2^{8(k−2)}\leq y \bmod N < 3.2^{8(k−2)}$
  * $y \bmod N < 3.2^{8(k−2)}/s$

* 以 $s' > s$ 重复上述过程。

* 通过二分查找选择 $s$。

#### IND-CCA安全结构：最优非对称加密（OAEP）

<img src="../img/OAEP.png" alt="OAEP" style="zoom: 50%;" />

$s=(m||0...0)\oplus G(r)$

$t=r\oplus H(s)$

$c=RSA.ENC_{pk}(s||t)$

### ElGamal



### Rabin



### ECC



### SM2

SM2是我国自主设计的椭圆曲线公钥密码算法，于2010年正式成为国家密码标准（GB/T 32918-2016），可全面替代RSA算法，在安全性、性能和资源占用上均有显著优势，广泛应用于数字签名、密钥交换和数据加密等场景。

#### 算法核心定义

SM2算法的基础是椭圆曲线密码学（ECC），其核心是在特定有限域上的椭圆曲线群中进行运算，具体定义包含以下关键要素：

1. **有限域选择**：采用素数域$$\mathbb{F}_P$$，其中$$p$$是一个满足特定安全要求的大素数，标准中规定$$p$$的比特长度可为256位、384位等，256位是目前最常用的安全级别。
2. **椭圆曲线方程**：在$$\mathbb{F}_p$$上定义的椭圆曲线方程为$$y^2 = x^3 + ax + b \pmod{p}$$，其中$$a$$和$$b$$是满足$$4a^3 + 27b^2 \not\equiv 0 \pmod{p}$$的域元素，以确保曲线无奇异点。
3. **基点与阶**：存在一个特定的基点$$G=(x_G, y_G)$$，它是椭圆曲线上的一个生成元，其阶为$$n$$（即$$nG=O$$，$$O$$为无穷远点）。$$n$$必须是一个大素数，且满足$$n > 2^{191}$$和$$n \not \mid p^k - 1$$（$$1 \leq k \leq 20$$），以抵抗离散对数相关攻击。
4. **密钥对生成**：
   1. 私钥：随机选择一个整数$$d$$，满足$$1 < d < n - 1$$；
   2. 公钥：通过椭圆曲线点乘计算$$P = dG$$，$$P$$是椭圆曲线上的一个点，与私钥$$d$$一一对应。

#### 核心运算流程

SM2算法的三大核心应用场景（数字签名、密钥交换、数据加密）对应不同的运算流程，具体如下：

##### 数字签名与验证

用于确认数据完整性和发送者身份，是SM2最常用的功能，流程分为“签名生成”和“签名验证”两步。

###### 签名生成

1. 对待签名数据$$M$$进行哈希处理，使用SM3密码杂凑算法计算摘要$$e = SM3(M)$$；
2. 随机选择一个整数$$k$$，满足$$1 < k < n - 1$$，计算点$$K = kG = (x_K, y_K)$$；
3. 计算$$r = (e + x_K) \pmod{n}$$，若$$r = 0$$或$$r + k = n$$，则重新选择$$k$$；
4. 计算$$s = [(1 + d)^{-1} \cdot (k - r \cdot d)] \pmod{n}$$，若$$s = 0$$，则重新选择$$k$$；
5. 最终签名结果为$$(r, s)$$，与数据$$M$$一同发送给接收方。

###### 签名验证

1. 接收数据$$M$$和签名$$(r, s)$$，先验证$$r$$和$$s$$是否满足$$1 \leq r, s \leq n - 1$$，不满足则验证失败；
2. 计算摘要$$e = SM3(M$$)，并计算$$t = (r + s) \pmod{n}$$，若$$t = $$0，则验证失败；
3. 计算点$$K' = sG + t$$，若$$K' = $$O（无穷远点），则验证失败；
4. 设$$K' = (x_{K'}, y_{K'})$$，计算$$r' = (e + x_{K'}) \pmod{n}$$；
5. 若$$r' = r$$，则签名验证通过；否则验证失败。

##### 密钥交换

用于通信双方在不安全信道上协商出一个共享会话密钥，流程需双方交互两次，以A（发起方）和B（响应方）为例：

1. **初始化**：A拥有私钥$$d_A$$和公钥$$P_A = d_AG $$；B拥有私钥$$d_B$$和公钥$$P_B = d_BG $$，双方已互相获取对方公钥。
2. **第一轮交互（A→B）**：
   1. A随机选整数$$k_A$$（$$1 < k_A < n - 1$$），计算$$K_A = k_AG $$，并将$$K_A$$发送给B；
3. **第二轮交互（B→A）**：
   1. B随机选整数$$k_B$$（$$1 < k_B < n - 1 $$），计算$$K_B = k_BG $$；
   2. B计算共享密钥材料$$S_B = d_B \cdot (K_A + [h]P_A)$$，其中$$h$$是椭圆曲线的余因子（标准中$$h=1$$）；
   3. B将$$K_B$$发送给A，并对$$K_A$$、$$K_B$$等信息生成验证数据；
4. **A计算共享密钥**：
   1. A验证B发送的验证数据，确认B身份；
   2. A计算共享密钥材料$$S_A = d_A \cdot (K_B + [h]P_B)$$；
5. **密钥派生**：A和B分别对$$S_A$$、$$S_B$$进行相同的密钥派生函数（KDF）处理，得到相同的会话密钥$$SK$$，用于后续数据加密。

##### 数据加密与解密

用于对敏感数据进行加密，确保仅指定接收方能解密，流程如下：

###### 加密

1. 获取接收方公钥$$P$$，验证$$P$$是否为椭圆曲线上的有效点且$$nP = O$$，无效则终止；
2. 随机选整数$$k$$（$$1 < k < n - $$），计算$$C_1 = k$$G（作为解密所需的“临时公钥”）；
3. 计算点$$S = k$$，若$$S = O$$，则重新选择$$k$$；设$$S = (x_S, y_S$$，将$$x_s$$和$$y_y$$拼接为字节串$$xSyS$$；
4. 对明文$$M$$进行分组（若需），使用对称密码算法（如SM4），以$$KDF(xSyS, len)$$生成的密钥加密$$M$$，得到密文$$C_2$$；
5. 计算$$C_3 = SM3(xSyS || M)$$（用于验证明文完整性）；
6. 最终密文为$$C = C_1 || C_2 || C_3$$，发送给接收方。

###### 解密

1. 接收密文$$c$$，拆分出$$C_1$$、$$C_2$$、$$C_3$$，验证$$C_1$$是否为椭圆曲线上的有效点，无效则解密失败；
2. 用私钥$$d$$计算点$$S = dC_1$$，若$$S = O$$，则解密失败；设$$S = (x_S, y_S)$$，拼接为$$xSyS$$；
3. 生成对称密钥$$K = KDF(xSyS, len)$$，解密$$C_2$$得到明文$$M$$；
4. 计算$$C_3' = SM3(xSyS || M')$$，若$$C_3' = C_3$$，则明文有效，$$M'$$为原始明文；否则解密失败。



## 数字签名

### RSA



### Elgamal



### DSA





## 密码协议

### 密钥分配



### 密钥协商

### 

### 秘密共享



### 身份识别



### 零知识证明


## 密码学工具

### openssl